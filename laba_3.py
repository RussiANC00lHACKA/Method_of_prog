# -*- coding: utf-8 -*-
"""laba_3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-Fa_WiJZo2jM_jUyFWMRxKJhGGjYPhMh
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install pycryptodome
# %pip install scipy
# %pip install matplotlib

import numpy as np
import time
import math
import random
from scipy.stats import chisquare
import matplotlib.pyplot as plt

## @package random_generators
#  This package includes implementations of various pseudo-random number generators (PRNGs) and statistical tests.

## Generate pseudo-random numbers using the middle-square method.
#  @param n Number of numbers to generate.
#  @return List of generated numbers.
def middle_multiply_gen(n):
    x, y = 123, 987
    vec = []
    for _ in range(n):
        next_val = (x * y) >> 16 & 0xffff
        next_val ^= (next_val << 13) & 0xffff
        next_val ^= (next_val >> 7) & 0xffff
        next_val ^= (next_val << 5) & 0xffff
        vec.append(next_val % 5001)
        x, y = y, next_val
    return vec

## Generate pseudo-random numbers using the XORSHIFT method.
#  @param n Number of numbers to generate.
#  @return List of generated numbers.
def xorshift_gen(n):
    x, y, z, w = np.uint64(548787455), np.uint64(842502087), np.uint64(3579807591), np.uint64(273326509)
    vec = []
    for _ in range(n):
        t = x ^ (x << np.uint64(11)) & np.uint64(0xFFFFFFFF)
        x, y, z = y, z, w
        w = w ^ (w >> np.uint64(19)) ^ t ^ (t >> np.uint64(8))
        vec.append(np.uint32(w % 5001))
    return vec

## Generate pseudo-random numbers using the standard method.
#  @param n Number of numbers to generate.
#  @return List of generated numbers.
def standard_random_gen(n):
    return [random.randint(0, 5000) for _ in range(n)]

# Generate samples
sample_sizes = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000, 5500, 6000]
sample_sizes_large = [1000, 5000, 10000, 20000, 50000, 100000, 500000, 1000000]

middle_samples = [middle_multiply_gen(size) for size in sample_sizes]
xorshift_samples = [xorshift_gen(size) for size in sample_sizes]
standard_samples = [standard_random_gen(size) for size in sample_sizes]

## Calculate statistics for a list of samples.
#  @param samples List of samples to calculate statistics for.
#  @return List of tuples containing mean, standard deviation, and coefficient of variation for each sample.
def calculate_statistics(samples):
    stats = []
    for sample in samples:
        sample = np.array(sample, dtype=np.float64)
        mean_val = np.mean(sample)
        std_dev = np.std(sample)
        variation_coefficient = (std_dev / mean_val) * 100
        stats.append((mean_val, std_dev, variation_coefficient))
    return stats

middle_stats = calculate_statistics(middle_samples)
xorshift_stats = calculate_statistics(xorshift_samples)
standard_stats = calculate_statistics(standard_samples)

## Print statistics for the specified generation method.
#  @param method_name Name of the generation method.
#  @param stats List of statistics to print.
def print_statistics(method_name, stats):
    print(f"Statistics for {method_name} method:")
    for mean_val, std_dev, variation_coefficient in stats:
        print(f"Mean: {mean_val}, Standard Deviation: {std_dev}, Coefficient of Variation: {variation_coefficient}")

print_statistics("middle-square", middle_stats)
print_statistics("XORSHIFT", xorshift_stats)
print_statistics("standard method", standard_stats)

## Perform Chi-square test for a sample.
#  @param sample List of sample data.
#  @param num_bins Number of bins for the histogram.
#  @return Tuple containing Chi-square statistic and p-value.
def chi_square_test(sample, num_bins):
    counts, _ = np.histogram(sample, bins=num_bins)
    chi2, p = chisquare(counts)
    return chi2, p

## Check uniformity of a list of samples using the Chi-square test.
#  @param samples List of samples to check.
#  @return List of tuples containing Chi-square statistic, p-value, and uniformity result for each sample.
def check_uniformity(samples):
    significance_level = 0.05
    results = []
    for sample in samples:
        chi2, p = chi_square_test(sample, 8)
        uniformity = "Uniform" if p > significance_level else "Non-uniform"
        results.append((chi2, p, uniformity))
    return results

middle_uniformity_results = check_uniformity(middle_samples)
xorshift_uniformity_results = check_uniformity(xorshift_samples)
standard_uniformity_results = check_uniformity(standard_samples)

## Print Chi-square test results for the specified generation method.
#  @param method_name Name of the generation method.
#  @param results List of Chi-square test results to print.
def print_chi_square_results(method_name, results):
    print(f"\nChi-square test for {method_name} method:")
    for chi2, p, uniformity in results:
        print(f"Chi-square: {chi2}, p-value: {p}, Result: {uniformity}")

print_chi_square_results("middle-square", middle_uniformity_results)
print_chi_square_results("XORSHIFT", xorshift_uniformity_results)
print_chi_square_results("standard method", standard_uniformity_results)

## Perform frequency test for a bit sequence.
#  @param bits Bit sequence to test.
#  @return p-value of the frequency test.
def frequency_test(bits):
    n = len(bits)
    s = sum([2*int(bit) - 1 for bit in bits])
    p_value = math.erfc(math.fabs(s) / (math.sqrt(n) * math.sqrt(2)))
    return p_value

## Perform runs test for a bit sequence.
#  @param bits Bit sequence to test.
#  @return p-value of the runs test.
def runs_test(bits):
    n = len(bits)
    pi = sum([int(bit) for bit in bits]) / n
    if math.fabs(pi - 0.5) > (2 / math.sqrt(n)):
        return 0.0
    v_n_obs = 1
    for i in range(1, n):
        if bits[i] != bits[i-1]:
            v_n_obs += 1
    p_value = math.erfc((v_n_obs - 2 * n * pi * (1 - pi)) / (2 * math.sqrt(2 * n) * pi * (1 - pi)))
    return p_value

## Perform monotonicity test for a bit sequence.
#  @param bits Bit sequence to test.
#  @return p-value of the monotonicity test.
def monotonicity_test(bits):
    n = len(bits)
    count = sum(int(bit) for bit in bits)
    p_value = binom_test(count, n, 0.5)
    return p_value

## Perform binomial test.
#  @param count Number of successful trials.
#  @param n Total number of trials.
#  @param p Probability of success in each trial.
#  @return p-value of the binomial test.
def binom_test(count, n, p):
    q = 1.0 - p
    k = min(count, n - count)
    p_value = 0.0
    for i in range(0, k + 1):
        curr_val = 1.0
        for j in range(1, i + 1):
            curr_val *= (n - j + 1) / j
        p_value += curr_val * (p**i) * (q**(n - i))
    return p_value

## Perform birthday spacings test for a sample.
#  @param sample List of sample data.
#  @param num_bins Number of bins for the histogram.
#  @return Tuple containing Chi-square statistic and p-value.
def birthday_spacings_test(sample, num_bins):
    sample = sorted(sample)
    spacings = [sample[i+1] - sample[i] for i in range(len(sample)-1)]
    counts, _ = np.histogram(spacings, bins=num_bins)
    chi2, p = chisquare(counts)
    return chi2, p

## Perform frequency test within blocks for a sample.
#  @param sample List of sample data.
#  @param block_size Size of each block.
#  @return List of p-values for each block.
def frequency_test_within_block(sample, block_size):
    blocks = [sample[i:i+block_size] for i in range(0, len(sample), block_size)]
    p_values = []
    for block in blocks:
        bits = ''.join([bin(num)[2:].zfill(32) for num in block])
        p_values.append(frequency_test(bits))
    return p_values

## Run NIST tests for a list of samples.
#  @param samples List of samples to test.
def run_nist_tests(samples):
    for sample in samples:
        bits = ''.join([bin(num)[2:].zfill(32) for num in sample])
        freq_p_value = frequency_test(bits)
        runs_p_value = runs_test(bits)
        mono_p_value = monotonicity_test(bits)
        birthday_chi2, birthday_p = birthday_spacings_test(sample, 8)
        freq_within_block_p_values = frequency_test_within_block(sample, 1000)

        print(f"Frequency test: p-value = {freq_p_value}")
        print(f"Runs test: p-value = {runs_p_value}")
        print(f"Monotonicity test: p-value = {mono_p_value}")
        print(f"Birthday spacings test: Chi-square = {birthday_chi2}, p-value = {birthday_p}")
        print(f"Frequency test within a block: p-values = {freq_within_block_p_values}\n")

print("NIST tests for middle-square method:")
run_nist_tests(middle_samples)

print("\nNIST tests for XORSHIFT method:")
run_nist_tests(xorshift_samples)

print("\nNIST tests for standard method:")
run_nist_tests(standard_samples)

## Measure generation time for a generator function.
#  @param generator Generator function to measure.
#  @param sample_sizes List of sample sizes to generate.
#  @return List of generation times in nanoseconds.
def measure_generation_time(generator, sample_sizes):
    times = []
    for size in sample_sizes:
        start_time = time.time_ns()
        generator(size)
        end_time = time.time_ns()
        times.append(end_time - start_time)
    return times

print("\nGeneration time for middle-square method:")
middle_times = measure_generation_time(middle_multiply_gen, sample_sizes_large)
for size, time_taken in zip(sample_sizes_large, middle_times):
    print(f"Size: {size}, Time: {time_taken} ns")

print("\nGeneration time for XORSHIFT method:")
xorshift_times = measure_generation_time(xorshift_gen, sample_sizes_large)
for size, time_taken in zip(sample_sizes_large, xorshift_times):
    print(f"Size: {size}, Time: {time_taken} ns")

print("\nGeneration time for standard method:")
standard_times = measure_generation_time(standard_random_gen, sample_sizes_large)
for size, time_taken in zip(sample_sizes_large, standard_times):
    print(f"Size: {size}, Time: {time_taken} ns")

## Plot generation times for different generators.
#  @param sample_sizes List of sample sizes.
#  @param middle_times List of generation times for middle-square method.
#  @param xorshift_times List of generation times for XORSHIFT method.
#  @param standard_times List of generation times for standard method.
def plot_generation_times(sample_sizes, middle_times, xorshift_times, standard_times):
    plt.figure(figsize=(10, 6))
    plt.plot(sample_sizes, middle_times, label='Middle-square', marker='o')
    plt.plot(sample_sizes, xorshift_times, label='XORSHIFT', marker='x')
    plt.plot(sample_sizes, standard_times, label='Standard method', marker='s')
    plt.xlabel('Sample size')
    plt.ylabel('Generation time (ns)')
    plt.title('Generation time vs. sample size')
    plt.legend()
    plt.grid(True)
    plt.show()

plot_generation_times(sample_sizes_large, middle_times, xorshift_times, standard_times)

